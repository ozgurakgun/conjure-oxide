diff --git a/crates/conjure_essence_macros/src/expand.rs b/crates/conjure_essence_macros/src/expand.rs
index 7c499c42c..6210ce665 100644
--- a/crates/conjure_essence_macros/src/expand.rs
+++ b/crates/conjure_essence_macros/src/expand.rs
@@ -1,11 +1,12 @@
 use super::expression::parse_expr_to_ts;
+use conjure_core::ast::SymbolTable;
 use conjure_essence_parser::util::{get_tree, query_toplevel};
 use proc_macro2::{TokenStream, TokenTree};
 use quote::{quote, ToTokens};
 use syn::{Error, LitStr, Result};
 use tree_sitter::Node;
 
-pub fn expand_expr(essence: &TokenTree) -> Result<TokenStream> {
+pub fn expand_expr(essence: &TokenTree, symbol_table: &SymbolTable) -> Result<TokenStream> {
     let src = to_src(essence);
     let (tree, source_code) =
         get_tree(&src).ok_or(Error::new(essence.span(), "Could not parse Essence AST"))?;
@@ -24,11 +25,11 @@ pub fn expand_expr(essence: &TokenTree) -> Result<TokenStream> {
     }
 
     // Parse expression and build the token stream
-    let expr = mk_expr(expr_node, &source_code, &root, essence)?;
+    let expr = mk_expr(expr_node, &source_code, &root, essence, symbol_table)?;
     Ok(expr)
 }
 
-pub fn expand_expr_vec(tt: &TokenTree) -> Result<TokenStream> {
+pub fn expand_expr_vec(tt: &TokenTree, symbol_table: &SymbolTable) -> Result<TokenStream> {
     let mut ans: Vec<TokenStream> = Vec::new();
     let src = to_src(tt);
     let (tree, source_code) =
@@ -37,15 +38,21 @@ pub fn expand_expr_vec(tt: &TokenTree) -> Result<TokenStream> {
 
     let query = query_toplevel(&root, &|n| n.kind() == "expression");
     for expr_node in query {
-        let expr = mk_expr(expr_node, &source_code, &root, tt)?;
+        let expr = mk_expr(expr_node, &source_code, &root, tt, symbol_table)?;
         ans.push(expr);
     }
     Ok(quote! { vec![#(#ans),*] })
 }
 
 /// Parse a single expression or make a compile time error
-fn mk_expr(node: Node, src: &str, root: &Node, tt: &TokenTree) -> Result<TokenStream> {
-    match parse_expr_to_ts(node, src, root) {
+fn mk_expr(
+    node: Node,
+    src: &str,
+    root: &Node,
+    tt: &TokenTree,
+    symbol_table: &SymbolTable,
+) -> Result<TokenStream> {
+    match parse_expr_to_ts(node, src, root, symbol_table) {
         Ok(expr) => Ok(expr),
         Err(err) => {
             let msg = format!("Error parsing Essence expression: {}", err);
diff --git a/crates/conjure_essence_macros/src/expression.rs b/crates/conjure_essence_macros/src/expression.rs
index a30389841..937e25966 100644
--- a/crates/conjure_essence_macros/src/expression.rs
+++ b/crates/conjure_essence_macros/src/expression.rs
@@ -1,3 +1,4 @@
+use conjure_core::ast::SymbolTable;
 use conjure_essence_parser::errors::EssenceParseError;
 use conjure_essence_parser::expression::child_expr;
 use conjure_essence_parser::util::named_children;
@@ -15,19 +16,22 @@ pub fn parse_expr_to_ts(
     constraint: Node,
     source_code: &str,
     root: &Node,
+    symbol_table: &SymbolTable,
 ) -> Result<TokenStream, EssenceParseError> {
     match constraint.kind() {
         "constraint" | "expression" | "boolean_expr" | "comparison_expr" | "arithmetic_expr"
-        | "primary_expr" | "sub_expr" => child_expr_to_ts(constraint, source_code, root),
+        | "primary_expr" | "sub_expr" => {
+            child_expr_to_ts(constraint, source_code, root, symbol_table)
+        }
         "not_expr" => {
-            let child = child_expr_to_ts(constraint, source_code, root)?;
+            let child = child_expr_to_ts(constraint, source_code, root, symbol_table)?;
             Ok(quote! {::conjure_core::ast::Expression::Not(
                 ::conjure_core::metadata::Metadata::new(),
                 Box::new(#child),
             )})
         }
         "abs_value" => {
-            let child = child_expr_to_ts(constraint, source_code, root)?;
+            let child = child_expr_to_ts(constraint, source_code, root, symbol_table)?;
             Ok(quote! {
                 ::conjure_core::ast::Expression::Abs(
                 ::conjure_core::metadata::Metadata::new(),
@@ -35,7 +39,7 @@ pub fn parse_expr_to_ts(
             )})
         }
         "negative_expr" => {
-            let child = child_expr_to_ts(constraint, source_code, root)?;
+            let child = child_expr_to_ts(constraint, source_code, root, symbol_table)?;
             Ok(quote! {::conjure_core::ast::Expression::Neg(
                 ::conjure_core::metadata::Metadata::new(),
                 Box::new(#child),
@@ -43,7 +47,7 @@ pub fn parse_expr_to_ts(
         }
         "exponent" | "product_expr" | "sum_expr" | "comparison" | "and_expr" | "or_expr"
         | "implication" => {
-            let expr1 = child_expr_to_ts(constraint, source_code, root)?;
+            let expr1 = child_expr_to_ts(constraint, source_code, root, symbol_table)?;
             let op = constraint.child(1).ok_or(format!(
                 "Missing operator in expression {}",
                 constraint.kind()
@@ -53,7 +57,7 @@ pub fn parse_expr_to_ts(
                 "Missing second operand in expression {}",
                 constraint.kind()
             ))?;
-            let expr2 = parse_expr_to_ts(expr2_node, source_code, root)?;
+            let expr2 = parse_expr_to_ts(expr2_node, source_code, root, symbol_table)?;
 
             match op_type {
                 "**" => Ok(quote! {::conjure_core::ast::Expression::UnsafePow(
@@ -138,7 +142,7 @@ pub fn parse_expr_to_ts(
         "quantifier_expr" => {
             let mut expr_list = Vec::new();
             for expr in named_children(&constraint) {
-                expr_list.push(parse_expr_to_ts(expr, source_code, root)?);
+                expr_list.push(parse_expr_to_ts(expr, source_code, root, symbol_table)?);
             }
 
             let quantifier = constraint.child(0).ok_or(format!(
@@ -211,8 +215,8 @@ pub fn parse_expr_to_ts(
         }
         "from_solution" => match root.kind() {
             "dominance_relation" => {
-                let inner_ts = child_expr_to_ts(constraint, source_code, root)?;
-                let inner = child_expr(constraint, source_code, root)?;
+                let inner_ts = child_expr_to_ts(constraint, source_code, root, symbol_table)?;
+                let inner = child_expr(constraint, source_code, root, symbol_table)?;
                 match inner {
                     ::conjure_core::ast::Expression::Atomic(_, _) => Ok(quote! {
                         ::conjure_core::ast::Expression::FromSolution(::conjure_core::metadata::Metadata::new(), Box::new(#inner_ts))
@@ -246,9 +250,10 @@ fn child_expr_to_ts(
     node: Node,
     source_code: &str,
     root: &Node,
+    symbol_table: &SymbolTable,
 ) -> Result<TokenStream, EssenceParseError> {
     match node.named_child(0) {
-        Some(child) => parse_expr_to_ts(child, source_code, root),
+        Some(child) => parse_expr_to_ts(child, source_code, root, symbol_table),
         None => Err(format!("Missing node in expression of kind {}", node.kind()).into()),
     }
 }
diff --git a/crates/conjure_essence_macros/src/lib.rs b/crates/conjure_essence_macros/src/lib.rs
index f09760065..48ff884df 100644
--- a/crates/conjure_essence_macros/src/lib.rs
+++ b/crates/conjure_essence_macros/src/lib.rs
@@ -1,3 +1,4 @@
+use conjure_core::ast::SymbolTable;
 use proc_macro::TokenStream;
 use proc_macro2::{Delimiter, Group, TokenStream as TokenStream2, TokenTree};
 
@@ -35,7 +36,9 @@ use expand::{expand_expr, expand_expr_vec};
 pub fn essence_expr(args: TokenStream) -> TokenStream {
     let ts = TokenStream2::from(args);
     let tt = TokenTree::Group(Group::new(Delimiter::None, ts));
-    match expand_expr(&tt) {
+
+    let dummy_symbols = SymbolTable::new();
+    match expand_expr(&tt, &dummy_symbols) {
         Ok(tokens) => tokens.into(),
         Err(err) => err.to_compile_error().into(),
     }
@@ -72,7 +75,8 @@ pub fn essence_expr(args: TokenStream) -> TokenStream {
 pub fn essence_vec(args: TokenStream) -> TokenStream {
     let ts = TokenStream2::from(args);
     let tt = TokenTree::Group(Group::new(Delimiter::None, ts));
-    match expand_expr_vec(&tt) {
+    let dummy_symbols = SymbolTable::new();
+    match expand_expr_vec(&tt, &dummy_symbols) {
         Ok(tokens) => tokens.into(),
         Err(err) => err.to_compile_error().into(),
     }
